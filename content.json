{"meta":{"title":"zyj's Blog","subtitle":null,"description":"代码改变世界","author":"ZYJ","url":"http://blog.zhouyajun.cn","root":"/"},"pages":[{"title":"分类","date":"2017-06-14T07:07:01.000Z","updated":"2019-06-04T03:31:43.634Z","comments":false,"path":"categories/index.html","permalink":"http://blog.zhouyajun.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-06-14T07:07:34.000Z","updated":"2019-06-04T03:31:43.635Z","comments":false,"path":"tags/index.html","permalink":"http://blog.zhouyajun.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo部署algolia搜索","slug":"hexo配置algolia搜索","date":"2019-06-04T03:31:43.633Z","updated":"2019-06-12T09:12:44.562Z","comments":true,"path":"2019/06/04/hexo配置algolia搜索/","link":"","permalink":"http://blog.zhouyajun.cn/2019/06/04/hexo配置algolia搜索/","excerpt":"注册algolia algolia官网 可以使用github 和谷歌账号 直接登录（直接跳过新手引导） 新建index","text":"注册algolia algolia官网 可以使用github 和谷歌账号 直接登录（直接跳过新手引导） 新建index 获取key放到站点配置文件里面（不是主题的配置文件）12345algolia: applicationID: 'applicationID' apiKey: 'apiKey-seach-only' indexName: 'indexName' chunkSize: 5000 所有的key都在如下界面获取 安装hexo-algolia扩展1npm install --save hexo-algolia 注意 theam 5.1版本以后要使用如下命令 1npm install hexo-algolia@0.2.0 更新index(在项目目录下)1hexo algolia 项目集成 更改主题配置文件 123456789# Algolia Searchalgolia_search: enable: true hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: \"We didn't find any results for the search: $&#123;query&#125;\" hits_stats: \"$&#123;hits&#125; results found in $&#123;time&#125; ms\" 将 enable 改为 true 即可，根据需要你可以调整 labels 中的文本。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.zhouyajun.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.zhouyajun.cn/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://blog.zhouyajun.cn/tags/博客/"},{"name":"algolia","slug":"algolia","permalink":"http://blog.zhouyajun.cn/tags/algolia/"}]},{"title":"hexo部署github pages","slug":"hexo部署github-pages","date":"2019-06-04T03:31:43.633Z","updated":"2019-06-04T03:31:43.633Z","comments":true,"path":"2019/06/04/hexo部署github-pages/","link":"","permalink":"http://blog.zhouyajun.cn/2019/06/04/hexo部署github-pages/","excerpt":"注册github 这里不多做解释,附上github地址：github 创建github page 仓库 建个github库。名字必须是 yourname.github.io yourname 就是你的github的用户名 例如：zhouyajun.github.io","text":"注册github 这里不多做解释,附上github地址：github 创建github page 仓库 建个github库。名字必须是 yourname.github.io yourname 就是你的github的用户名 例如：zhouyajun.github.io 在本机生成ssh key12ssh-keygen -t rsa -C \"你的邮箱地址\"一路回车 enter 生成的key一般位于C:\\Users\\Administrator.ssh文件夹中 找到.id_rsa.pub文件,打开，并复制其中内容 登录github,找到setting-&gt;ssh GPG keys页面，添加sshkey 用你刚刚复制的is_rsa.pub里面的内容复制到github add ssh key页面中 至此，ssh秘钥配置完成 配置hexo项目中的自动部署 打开 _config.yml文件 ,找到并修改如下代码 1234deploy: type: git repository: git@github.com:zhouyajun/zhouyajun.github.io.git branch: master 注：type:HEXO更新到3.0之后，deploy的type 的github需要改成git 必须事先安装hexo-deplorer-git扩展,否则会报 ERROR Deployer not found: git 的错误 1npm install hexo-deployer-git --save 配置完成 执行部署123hexo cleanhexo ghexo deploy","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.zhouyajun.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.zhouyajun.cn/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://blog.zhouyajun.cn/tags/博客/"}]},{"title":"apidoc详解","slug":"apidoc详解","date":"2019-06-04T03:31:43.632Z","updated":"2019-06-04T03:31:43.632Z","comments":true,"path":"2019/06/04/apidoc详解/","link":"","permalink":"http://blog.zhouyajun.cn/2019/06/04/apidoc详解/","excerpt":"","text":"ApiDoc使用详解参考项目文档：apidoc官方文档1. 安装apidoc 注意：首先要安装npm网上搜索安装命令：npm install apidoc -g 2.安装grunt modulenpm install grunt-apidoc --save-dev 3.配置apidoc.json或者package.json文件 12345678910111213141516171819202122232425&#123; \"name\": \"项目名称\", \"version\": \"版本号\", \"description\": \"项目描述\", \"title\":\"浏览器网页标题\", \"url\":\"请求的路径前面的服务器地址\", \"sampleUrl\":\"模拟请求的地址\"（如果设置，所有接口都会有个模拟请求的界面）, \"header\": &#123;//没试过 \"title\": \"My own header title\", \"filename\": \"header.md\" &#125;, \"footer\": &#123; \"title\": \"My own footer title\", \"filename\": \"footer.md\" &#125;, \"order\":&#123; //排序，没试过 &#125;, \"template\":&#123; \"forceLanguage\":\"zh_cn\",//语言 \"withCompare\":true //是否开启比较版本功能（默认true）, \"withGenerator\":true //是否开启生成信息在页脚（默认true）, \"jQueryAjaxSetup\":object //ajax请求（未尝试） &#125;&#125; 4.apidoc接口文档参数详解 @api {method} /path/to/:uid [title] 注：定义接口名，请求方式,路径（必填，除了apiDefine） 123/** * @api &#123;post&#125; /user/reg 用户注册 */ @apiDefine name [title] 注：定义公共文档块，可使用apiUse在其他文档中插入 123456789/** * @apiDefine MyError * @apiError UserNotFound The &lt;code&gt;id&lt;/code&gt; of the User was not found. *//** * @api &#123;get&#125; /user/:id * @apiUse MyError */ @apiDescription text 注：接口描述 123/***@apiDescription 用户登录接口*/ @apiName name 注：接口名（必填，用户文档左侧菜单二级分类） 123/***@apiName login*/ @apiGroup group 注：接口分组（必填，用户文档左侧菜单一级分类） 123/***@apiGroup user*/ @apiVersion 1.1.1 注：接口版本号（必须是：major.minor.patch格式：1.0.0） 123/***@apiVersion 1.0.0*/ @apiDeprecated text 注：未测试 123/***@apiDeprecated text*/ @apiIgnore [hint] 注：忽略的接口[hint]为忽略的原因，可选 123/***@apiIgnore hint*/ @apiPermission name 注：api的权限名 123/***@apiPermission admin*/ @apiParam [(group)] [{type}] [field=defaultValue] [description] 注：接口参数{type}包括：{String} 字符串，{Boolean}布尔值, {Number}数字, {Object}对象, {String[]}字符串数组[field] 可选参数fieldfield 必选参数 field=’string’ 参数默认值{type{size}} 代表字符长度{String{6-12}}[description] 字段描述 1234567891011/** * @api &#123;post&#125; /user/ * @apiParam &#123;String&#125; [firstname] Optional Firstname of the User. * @apiParam &#123;String&#125; lastname Mandatory Lastname. * @apiParam &#123;String&#125; country=\"DE\" Mandatory with default value \"DE\". * @apiParam &#123;Number&#125; [age=18] Optional Age with default 18. * * @apiParam (Login) &#123;String&#125; pass Only logged in users can post this. * In generated documentation a separate * \"Login\" Block will be generated. */ @apiSuccess [(group)] [{type}] field [description] 注：接口返回值显示{type}包括：{String} 字符串，{Boolean}布尔值, {Number}数字, {Object}对象, {String[]}字符串数组field 返回字段名[description] 字段描述 12345/** * @api &#123;get&#125; /user/:id * @apiSuccess (200) &#123;String&#125; firstname Firstname of the User. * @apiSuccess (200) &#123;String&#125; lastname Lastname of the User. */ @apiSuccessExample [{type}] [title] example 注：接口返回值显示{type}包括：{json}title 返回说明：[example] 返回例子 123456789/** * @api &#123;get&#125; /user/:id * @apiSuccessExample &#123;json&#125; Success-Response: * HTTP/1.1 200 OK * &#123; * \"firstname\": \"John\", * \"lastname\": \"Doe\" * &#125; */ 5.版本比较 要保留两份，后新的版本的时候。保留原来的版本说明，复制修改为新的版本，另外修改新的版本号 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * @api &#123;post&#125; /index/index 首页接口 * @apiVersion 1.1.0 * @apiDescription 首页获取数据 * @apiName index * @apiGroup Index * * @apiUse token * @apiParam &#123;string&#125; [page=1] 页数 * @apiParam &#123;string&#125; [limit=10] 每页条数 * @apiParam &#123;string&#125; [name] 搜索名 * * @apiUse tokenError * * @apiSuccessExample &#123;json&#125; 成功返回： * &#123; \"status\": \"1\", \"code\": \"200\", \"message\": \"成功\", \"data\": &#123; \"noticeList\": [ &#123; \"pic\": \"http://xblj.oss-cn-hangzhou.aliyuncs.com/khw_server/user/1/credential/1498805411211761.png\", \"url\": \"http://www.local.com/xblj/khw/server/api/web/index.php/page/notice?id=6\", \"id\": \"6\" &#125; ], \"courseList\": [ &#123; \"type_name\": \"客运\", \"type\": \"1\", \"course_name\": \"测试\", \"price\": \"20.00\", \"cover_pic\": \"http://xblj.oss-cn-hangzhou.aliyuncs.com/khw_server/user/1/credential/1498805411211761.png\", \"buy_times\": \"10\", \"course_id\": \"1\" &#125; ] &#125; &#125; */ /** * @api &#123;post&#125; /index/index 首页接口 * @apiVersion 1.2.0 * @apiDescription 首页获取数据 * @apiName index * @apiGroup Index * * @apiUse token * @apiParam &#123;string&#125; [page=1] 页数 * @apiParam &#123;string&#125; [limit=10] 每页条数 * * @apiUse tokenError * * * @apiSuccessExample &#123;json&#125; 成功返回： * &#123; \"status\": \"1\", \"code\": \"200\", \"message\": \"成功\", \"data\": &#123; \"noticeList\": [ &#123; \"pic\": \"http://xblj.oss-cn-hangzhou.aliyuncs.com/khw_server/user/1/credential/1498805411211761.png\", \"url\": \"http://www.local.com/xblj/khw/server/api/web/index.php/page/notice?id=6\", \"id\": \"6\" &#125; ], \"courseList\": [ &#123; \"type_name\": \"客运\", \"type\": \"1\", \"course_name\": \"测试\", \"price\": \"20.00\", \"cover_pic\": \"http://xblj.oss-cn-hangzhou.aliyuncs.com/khw_server/user/1/credential/1498805411211761.png\", \"buy_times\": \"10\", \"course_id\": \"1\" &#125; ] &#125; &#125; */","categories":[{"name":"api","slug":"api","permalink":"http://blog.zhouyajun.cn/categories/api/"}],"tags":[{"name":"api","slug":"api","permalink":"http://blog.zhouyajun.cn/tags/api/"}]},{"title":"hexo+github+hexo-theam-next个人博客","slug":"hexo-github-hexo-theam-next个人博客","date":"2019-06-04T03:31:43.632Z","updated":"2019-06-04T03:31:43.632Z","comments":true,"path":"2019/06/04/hexo-github-hexo-theam-next个人博客/","link":"","permalink":"http://blog.zhouyajun.cn/2019/06/04/hexo-github-hexo-theam-next个人博客/","excerpt":"源码下载 12git clone git@git.oschina.net:yajun0310/blog.gitgit clone https://git.oschina.net/yajun0310/blog.git 安装npm依赖module1cd blog 1npm install","text":"源码下载 12git clone git@git.oschina.net:yajun0310/blog.gitgit clone https://git.oschina.net/yajun0310/blog.git 安装npm依赖module1cd blog 1npm install 安装部署脚本 1npm install hexo-deployer-git --save 安装rss扩展 1npm install hexo-generator-feed --save 执行hexo命令查看预览1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s -p 80 查看预览在浏览器中输入localhost","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.zhouyajun.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.zhouyajun.cn/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://blog.zhouyajun.cn/tags/博客/"},{"name":"theam-next","slug":"theam-next","permalink":"http://blog.zhouyajun.cn/tags/theam-next/"},{"name":"next","slug":"next","permalink":"http://blog.zhouyajun.cn/tags/next/"}]},{"title":"array_merge() 函数详解","slug":"2016-6-27-array-merge","date":"2019-06-04T03:31:43.628Z","updated":"2019-06-04T03:31:43.628Z","comments":true,"path":"2019/06/04/2016-6-27-array-merge/","link":"","permalink":"http://blog.zhouyajun.cn/2019/06/04/2016-6-27-array-merge/","excerpt":"关联数组123456789101112131415 $a = [ 'a'=&gt;'abc', 'b'=&gt;'ccc', 'c'=&gt;'ddd'];$b = [ 'a'=&gt;'122', 'b'=&gt;'333', 'd'=&gt;'ddd' ]; $c = array_merge($a,$b); var_dump($c); 很显然，关联数组会根据键名合并，若数组键名相同，第二个数组合并第一个，返回如下","text":"关联数组123456789101112131415 $a = [ 'a'=&gt;'abc', 'b'=&gt;'ccc', 'c'=&gt;'ddd'];$b = [ 'a'=&gt;'122', 'b'=&gt;'333', 'd'=&gt;'ddd' ]; $c = array_merge($a,$b); var_dump($c); 很显然，关联数组会根据键名合并，若数组键名相同，第二个数组合并第一个，返回如下 12345678910 array(4) &#123; [\"a\"]=&gt; string(3) \"122\" [\"b\"]=&gt; string(3) \"333\" [\"c\"]=&gt; string(3) \"ddd\" [\"d\"]=&gt; string(3) \"ddd\"&#125; 索引数组1234567 $a = ['a','b','c'];$b = ['b','c','d']; $c = array_merge($a,$b); var_dump($c); 索引数组是完全合并两个数组 1234567891011121314array(6) &#123; [0]=&gt; string(1) \"a\" [1]=&gt; string(1) \"b\" [2]=&gt; string(1) \"c\" [3]=&gt; string(1) \"b\" [4]=&gt; string(1) \"c\" [5]=&gt; string(1) \"d\"&#125;","categories":[{"name":"php","slug":"php","permalink":"http://blog.zhouyajun.cn/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://blog.zhouyajun.cn/tags/php/"},{"name":"函数","slug":"函数","permalink":"http://blog.zhouyajun.cn/tags/函数/"}]},{"title":"mysql用户远程登录","slug":"2016-7-5-myaql-1","date":"2019-06-04T03:31:43.628Z","updated":"2019-06-04T03:31:43.628Z","comments":true,"path":"2019/06/04/2016-7-5-myaql-1/","link":"","permalink":"http://blog.zhouyajun.cn/2019/06/04/2016-7-5-myaql-1/","excerpt":"方法一1234567891011command 1:grant (all privileges) on database.table to username@'ip' idenitfied by 'password' with grant option;command 2:flush privileges;","text":"方法一1234567891011command 1:grant (all privileges) on database.table to username@'ip' idenitfied by 'password' with grant option;command 2:flush privileges; all privileges 可以替换为相应的权限 比如：select,update,insert username 为mysql 用户名 ip 为可以远程访问的ip,%代表所有地址都可以访问 password 为 密码","categories":[{"name":"mysql","slug":"mysql","permalink":"http://blog.zhouyajun.cn/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.zhouyajun.cn/tags/mysql/"},{"name":"方法","slug":"方法","permalink":"http://blog.zhouyajun.cn/tags/方法/"}]},{"title":"php 设计模式(单例模式)","slug":"2016-6-27-php设计模式","date":"2019-06-04T03:31:43.628Z","updated":"2019-06-04T03:31:43.628Z","comments":true,"path":"2019/06/04/2016-6-27-php设计模式/","link":"","permalink":"http://blog.zhouyajun.cn/2019/06/04/2016-6-27-php设计模式/","excerpt":"生成对象单例模式- 系统中只能有一个对象 - 该对象可以被所有其他对象调用 - 该对象不能存储到可改变的全局变量中","text":"生成对象单例模式- 系统中只能有一个对象 - 该对象可以被所有其他对象调用 - 该对象不能存储到可改变的全局变量中 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Created by ZYJ. * User: ZYJ * Date: 2016/10/14 * Time: 11:55 */namespace study;class Singleton&#123; private $pro = array(); private static $instance; private function __construct() &#123; &#125; private function __clone() &#123; throw new \\Exception('无法克隆'); &#125; /** * @param array $pro */ public function setPro( $key, $val ) &#123; $this-&gt;pro[$key] = $val; &#125; /** * @return array */ public function getPro( $key ) &#123; return $this-&gt;pro[$key]; &#125; /** * 单例模式生成对象 * @return Singleton */ public static function getInstance() &#123; if (empty(self::$instance)) &#123; self::$instance = new self(); &#125; return self::$instance; &#125;&#125;","categories":[{"name":"php","slug":"php","permalink":"http://blog.zhouyajun.cn/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://blog.zhouyajun.cn/tags/php/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.zhouyajun.cn/tags/设计模式/"}]},{"title":"go操作mysql数据库","slug":"go操作mysql数据库","date":"2018-08-27T03:54:12.000Z","updated":"2019-06-04T03:31:43.632Z","comments":true,"path":"2018/08/27/go操作mysql数据库/","link":"","permalink":"http://blog.zhouyajun.cn/2018/08/27/go操作mysql数据库/","excerpt":"","text":"go操作mysql数据库示例数据库结构数据库test，用户表userinfo，关联用户信息表userdetail 1234567891011121314CREATE TABLE `userinfo` ( `uid` INT(10) NOT NULL AUTO_INCREMENT, `username` VARCHAR(64) NULL DEFAULT NULL, `department` VARCHAR(64) NULL DEFAULT NULL, `created` DATE NULL DEFAULT NULL, PRIMARY KEY (`uid`));CREATE TABLE `userdetail` ( `uid` INT(10) NOT NULL DEFAULT '0', `intro` TEXT NULL, `profile` TEXT NULL, PRIMARY KEY (`uid`)) 操作数据库1 引入库文件1234import ( \"database/sql\" _ \"github.com/go-sql-driver/mysql\") 2 连接数据库123456789//host 数据库地址//port mysql端口//database 连接的数据库db,err := sql.open(\"mysql\",\"用户名：密码@tcp(host:port)/database\")if err != nil &#123; panic(err)&#125;//关闭数据库defer db.Close() 3 插入数据123456//插入语句预处理stmt,err := db.Prepare(\"INSERT userinfo set username=?,department=?,created_at=?\")//插入数据res,err := stmt.Exec(\"test\",\"销售部门\",\"2018-05-10\")//获取上次插入的idid,err := res.lastInsertId() 4 查询数据123456789101112131415//获取数据库的所有字段res,err := db.Query(\"select * from userinfo\")res.Columns()//获取单挑数据res := db.QueryRow(\"select * from userinfo\")res.scan(&amp;uid,&amp;username,&amp;department,&amp;created_at)//获取多条数据结果stmt,err := db.Prepare(\"select * from userinfo where uid=?\")res,err := stmt.Query(1)//循环获取单挑数据for res.Next()&#123; res.scan(&amp;uid,&amp;username,&amp;department,&amp;created_at)&#125; 5 修改数据1234stmt,_ := db.Prepare(\"update userinfo set username=? where id = ?\")res,_ := stmt.Exec(\"test\",1)//受影响的行数res.RowsAffected() 6 删除数据123stmt,_ := db.Prepare(\"Delete from userinfo where uid=?\")res,_ := stmt.Exec(1)res.RowsAffected()","categories":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/tags/go/"}]},{"title":"go语言学习之并发","slug":"go语言学习之并发","date":"2018-08-11T14:15:09.000Z","updated":"2019-06-04T03:31:43.632Z","comments":true,"path":"2018/08/11/go语言学习之并发/","link":"","permalink":"http://blog.zhouyajun.cn/2018/08/11/go语言学习之并发/","excerpt":"","text":"go 并发goroutine goroutine是Go并行设计的核心。goroutine说到底其实就是协程，但是它比线程更小 Go语言内部帮你实现了这些goroutine之间的内存共享 执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务 goroutine比thread更易用、更高效、更轻便 goroutine是通过Go的runtime管理的一个线程管理器。goroutine通过go关键字实现了，其实就是一个普通的函数。1go hello(a,b,c) channels定义一个channel时，也需要定义发送到channel的值的类型,注意：必须使用make 创建channelchannel通过操作符&lt;-来接收和发送数据 1234567var c = make(chan int)var b = make(chan string)var c = make(chan interface&#123;&#125;)//存入数据c &lt;- 'abc'//取出数据value := &lt;-c 默认情况下，channel接收和发送数据都是阻塞的 buffered channels (带缓冲的channels)123ch := make(chan type,value)//创建带有4个缓冲的线程ch := make(chan type, 4) 注意： range (使用range方法读取channels里面的数据) close() 关闭channel，应该在生产者 12345678910111213141516171819202122package mainimport ( \"fmt\")func fibonacci(n int, c chan int) &#123; x, y := 1, 1 for i := 0; i &lt; n; i++ &#123; c &lt;- x x, y = y, x + y &#125; close(c)&#125;func main() &#123; c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c &#123; fmt.Println(i) &#125;&#125; select (switch切换channel)select默认是阻塞的，只有当监听的channel中有发送或接收可以进行时才会运行，当多个channel都准备好的时候，select是随机的选择一个执行的。 12345678910111213141516171819202122232425262728package mainimport \"fmt\"func fibonacci(c, quit chan int) &#123; x, y := 1, 1 for &#123; select &#123; case c &lt;- x: x, y = y, x + y case &lt;-quit: fmt.Println(\"quit\") return &#125; &#125;&#125;func main() &#123; c := make(chan int) quit := make(chan int) go func() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(&lt;-c) &#125; quit &lt;- 0 &#125;() fibonacci(c, quit)&#125; select设置超时1234567891011121314151617func main() &#123; c := make(chan int) o := make(chan bool) go func() &#123; for &#123; select &#123; case v := &lt;- c: println(v) case &lt;- time.After(5 * time.Second): println(\"timeout\") o &lt;- true break &#125; &#125; &#125;() &lt;- o&#125; runtime gotoutineruntime包中有几个处理goroutine的函数： Goexit 退出当前执行的goroutine，但是defer函数还会继续调用 Gosched 让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。 NumCPU 返回 CPU 核数量 NumGoroutine 返回正在执行和排队的任务总数 GOMAXPROCS 用来设置可以并行计算的CPU核数的最大值，并返回之前的值。","categories":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/tags/go/"}]},{"title":"go基础巩固","slug":"go基础巩固","date":"2018-08-09T02:58:16.000Z","updated":"2019-06-04T03:31:43.631Z","comments":true,"path":"2018/08/09/go基础巩固/","link":"","permalink":"http://blog.zhouyajun.cn/2018/08/09/go基础巩固/","excerpt":"go基础巩固_（下划线）下划线是一个特殊的变量名，任何赋予它的值都会被丢弃 iotaGo里面有一个关键字iota，这个关键字用来声明enum的时候采用，它默认开始值是0，const中每增加一行加1 make,new操作符内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。 1new 返回指针 内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值 1make返回初始化后的（非零）值。","text":"go基础巩固_（下划线）下划线是一个特殊的变量名，任何赋予它的值都会被丢弃 iotaGo里面有一个关键字iota，这个关键字用来声明enum的时候采用，它默认开始值是0，const中每增加一行加1 make,new操作符内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。 1new 返回指针 内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值 1make返回初始化后的（非零）值。 goto用goto跳转到必须在当前函数内定义的标签标签：这行的第一个词，以冒号结束作为标签，标签大小写敏感 12345678func test() int&#123; a := 1HERE: println(i) a++ goto HERE &#125; switchgo的switch-case结构里面。默认带有break fallthroughswitch-case ，找到匹配的case值后，默认会跳出结构，fallthrough 关键字 可以强制执行后面的case代码 Go函数支持变参接受变参的函数是有着不定数量的参数,示例如下： 123456func test(arg ...int)(x,y int)&#123; // arg 是一个slice结构 for i,v := range arg&#123; &#125;&#125; deferGo语言中有种不错的设计，即延迟（defer）语句，你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。 1234567891011func ReadWrite() bool &#123; file.Open(\"file\") defer file.Close() if failureX &#123; return false &#125; if failureY &#123; return false &#125; return true&#125; main()函数和init()函数Go里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main）这两个函数在定义时不能有任何的参数和返回值虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个package中每个文件只写一个init函数Go程序会自动调用init()和main()，所以你不需要在任何地方调用这两个函数每个package中的init函数都是可选的，但package main就必须包含一个main函数注意: main包中，如果既有init()函数也有main函数，会先执行init()函数 import 导入包的几种特殊写法 .导入包名前面加点，可以在使用包里面函数的时候，忽略包名 12345678import ( .\"fmt\")//不加点使用fmt.Println()//加点使用Println() 别名操作顾名思义，就是可以给包起个别名 12345import ( f \"fmt\")//使用f.Println() _操作带_的操作，实质不是引入包的函数，而是执行包的init()函数 结构体（自定义类型）匿名字段（嵌入字段）当匿名字段是一个struct的时候，那么这个struct所拥有的全部字段都被隐式地引入了当前定义的这个struct这里有一个问题：如果human里面有一个字段叫做phone，而student也有一个字段叫做phone，那么该怎么办呢？Go里面很简单的解决了这个问题，最外层的优先访问，也就是当你通过student.phone访问的时候，是访问student里面的字段，而不是human里面的字段。 1234type User struct&#123; name string age int&#125; interface简单的说，interface是一组method签名的组合，我们通过interface来定义对象的一组行为interface可以被任意的对象实现一个对象可以实现任意多个interface任意的类型都实现了空interface(我们这样定义：interface{})，也就是包含0个method的interface 12345678910111213141516171819202122type User struct&#123; name string age int&#125;type Student struct&#123; User lesson string&#125;type Teacher struct&#123; User teach_card string&#125;func (user User) sing(a string)&#123;&#125;func(user User) sayHi()&#123;&#125;type Men interface&#123; sing(a string) sayHi()&#125; 注意：一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值 嵌入interface跟嵌入struct字段一样，interface也可以嵌入interface嵌入其他interface,该interface就会拥有其他interface的所有方法 12345678type a interface&#123; a() b()&#125;type b interface&#123; a c()&#125; 反射Go语言实现了反射，所谓反射就是能检查程序在运行时的状态","categories":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/tags/go/"}]},{"title":"go命令","slug":"go命令","date":"2018-08-08T06:11:51.000Z","updated":"2019-06-04T03:31:43.631Z","comments":true,"path":"2018/08/08/go命令/","link":"","permalink":"http://blog.zhouyajun.cn/2018/08/08/go命令/","excerpt":"GO 命令go build说明这个命令主要用于编译代码。 如果是普通包（不是main包） go build 命令不会生成任何文件 如果是main包，go build命令会在当前目录（执行命令的目录）生成二进制文件 如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在go build之后加上文件名，例如go build a.go；go build命令默认会编译当前目录下的所有go文件 go build后面跟目录，是相对于GOPATH下的src目录，例如：go build hello,找的是$GOPATH/src/hello目录 go build 不会递归编译，只会编译当前目录 go build会忽略目录下以“_”或“.”开头的go文件常用参数-i:编译同时安装相应的包= \bbuild +install-o:编译同时\b指定生成的文件名-n:把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的-x:打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行-v 打印出来我们正在编译的包名-compiler name 指定相应的编译器，gccgo还是gc","text":"GO 命令go build说明这个命令主要用于编译代码。 如果是普通包（不是main包） go build 命令不会生成任何文件 如果是main包，go build命令会在当前目录（执行命令的目录）生成二进制文件 如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在go build之后加上文件名，例如go build a.go；go build命令默认会编译当前目录下的所有go文件 go build后面跟目录，是相对于GOPATH下的src目录，例如：go build hello,找的是$GOPATH/src/hello目录 go build 不会递归编译，只会编译当前目录 go build会忽略目录下以“_”或“.”开头的go文件常用参数-i:编译同时安装相应的包= \bbuild +install-o:编译同时\b指定生成的文件名-n:把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的-x:打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行-v 打印出来我们正在编译的包名-compiler name 指定相应的编译器，gccgo还是gc go clean说明这个命令是用来移除当前源码包和关联源码包里面编译生成的文件。 \b常用参数-i 清除关联的安装的包和可运行文件，也就是通过go install安装的文件-n 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的-r 循环的清除在import中引入的包-x 打印出来执行的详细命令，其实就是-n打印的执行版本 go install说明这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg\b或者$GOPATH/bin中。 常用参数-i:编译同时安装相应的包= \bbuild +install-o:编译同时\b指定生成的文件名-n:把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的-x:打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行-v 打印出来我们正在编译的包名-compiler name 指定相应的编译器，gccgo还是gc go fmt说明使用go fmt命令，其实是调用了gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w -l src，可以格式化整个项目。 gofmt参数说明-l 显示那些需要格式化的文件-w 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。-r 添加形如“a[b:len(a)] -&gt; a[b:]”的重写规则，方便我们做批量替换-s 简化文件中的代码-d 显示格式化前后的diff而不是写入文件，默认是false-e 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误。-cpuprofile 支持调试模式，写入相应的cpufile到指定的文件 go get说明这个命令是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install ####参数介绍： -d 只下载不安装-f 只有在你包含了-u参数的时候才有效，不让-u去验证import中的每一个都已经获取了，这对于本地fork的包特别有用-fix 在获取源码之后先运行fix，然后再去做其他的事情-t 同时也下载需要为运行测试所需要的包-u强制使用网络去更新包和它的依赖包-v 显示执行的命令 godoc####说明在Go1.2版本之前还支持go doc命令，但是之后全部移到了godoc这个命令下，需要这样安装go get golang.org/x/tools/cmd/godoc 使用 查看包里的函数列表 12godoc net/httpgodoc fmt 查看函数说明 12godoc fmt Printfgodoc fmt Sprintf 使用本地在线文档 1godoc -http=:8181 然后打开127.0.0.1:8181访问本地文档 go test说明执行这个命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕 参数说明-bench regexp 执行相应的benchmarks，例如 -bench=.-cover 开启测试覆盖率-run regexp 只运行regexp匹配的函数，例如 -run=Array 那么就执行包含有Array开头的函数-v 显示测试的详细命令 go generate说明这个命令是从Go1.4开始才设计的，用于在编译前自动化生成某类代码。go generate和go build是完全不一样的命令，通过分析源码中特殊的注释，然后执行相应的命令。这些命令都是很明确的，没有任何的依赖在里面。而且大家在用这个之前心里面一定要有一个理念，这个go generate是给你用的，不是给使用你这个包的人用的，是方便你来生成一些代码的 使用说明这里我们来举一个简单的例子，例如我们经常会使用yacc来生成代码，那么我们常用这样的命令： go tool yacc -o gopher.go -p parser gopher.y-o 指定了输出的文件名， -p指定了package的名称，这是一个单独的命令，如果我们想让go generate来触发这个命令，那么就可以在当然目录的任意一个xxx.go文件里面的任意位置增加一行如下的注释： //go:generate go tool yacc -o gopher.go -p parser gopher.y这里我们注意了，//go:generate是没有任何空格的，这其实就是一个固定的格式，在扫描源码文件的时候就是根据这个来判断的。 所以我们可以通过如下的命令来生成，编译，测试。如果gopher.y文件有修改，那么就重新执行go generate重新生成文件就好。 123go generatego buildgo test 其他命令 go env 查看当前go的环境变量 go version 查看当前go版本 go list 列出当前全部安装的package go run编译并运行Go程序 go help 命令 获取命令帮助","categories":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/tags/go/"}]},{"title":"go语言学习接口与方法","slug":"go语言学习接口与方法","date":"2018-08-07T14:03:01.000Z","updated":"2019-06-04T03:31:43.631Z","comments":true,"path":"2018/08/07/go语言学习接口与方法/","link":"","permalink":"http://blog.zhouyajun.cn/2018/08/07/go语言学习接口与方法/","excerpt":"","text":"方法Go 没有类。不过你可以为结构体类型定义方法。方法就是一类带特殊的 接收者 参数的函数。方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。 12345678910type v struct &#123; x, y int &#125;func (test v) Abs() int&#123; return math.Sqrt(v.x*v.x + v.y*v.y)&#125;//使用test := v&#123;1,2&#125;test.Abs() 记住：方法只是个带接收者参数的函数。 你也可以为非结构体类型声明方法。123456789101112type MyFloat float64func (f MyFloat) Abs() float64&#123; if f&lt;0 &#123; return float64(-f) &#125;else&#123; return float64(f) &#125;&#125;//使用f := MyFloat(-math.Sqrt2)f.Abs() 指针接收者你可以为指针接收者声明方法。这意味着对于某类型 T，接收者的类型可以用 *T 的文法。指针接收者的方法可以修改接收者指向的值 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"math\")type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs()) v.Scale(10) fmt.Println(v.Abs())&#125;//返回550 方法与指针重定向带指针参数的函数必须接受一个指针以指针为接收者的方法被调用时，接收者既能为值又能为指针 接受一个值作为参数的函数必须接受一个指定类型的值而以值为接收者的方法被调用时，接收者既能为值又能为指针 选择值或指针作为接收者使用指针接收者的原因有二： 首先，方法能够修改其接收者指向的值。 其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效 接口接口类型 是有一组方法签名定义的集合接口类型的变量可以保存任何实现了这些方法的值 接口与隐式实现类型通过实现一个接口的所有方法来实现该接口隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义在内部，接口值可以看做包含值和具体类型的元组：(value, type)接口值保存了一个具体底层类型的具体值接口值调用方法时会执行其底层类型的同名方法 底层值为 nil 的接口值即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。 在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 M 方法）。 注意： 保存了 nil 具体值的接口其自身并不为 nil。 空接口指定了零个方法的接口值被称为 空接口： 1interface&#123;&#125; 空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。 类型断言类型断言提供了访问接口值底层具体值的方式 1234t := i.(T)//t为接口底层的值t,ok := i.(T)//ok返回ture或者false 类型选择类型选择 是一种按顺序从几个类型断言中选择分支的结构。 类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。 12345678switch v := i.(type)&#123; //注意：type为关键字 case T: // v 的类型为 T case S: // v 的类型为 S default: // 没有匹配，v 与 i 的类型相同&#125; 类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。 此选择语句判断接口值 i 保存的值类型是 T 还是 S。在 T 或 S 的情况下，变量 v 会分别按 T 或 S 类型保存 i 拥有的值。在默认（即没有匹配）的情况下，变量 v 与 i 的接口类型和值相同。 练习：Stringer通过让 IPAddr 类型实现 fmt.Stringer 来打印点号分隔的地址。 例如，IPAddr{1, 2, 3, 4} 应当打印为 “1.2.3.4”。 12345678910111213141516171819202122package mainimport \"fmt\"type IPAddr [4]byte// TODO: Add a \"String() string\" method to IPAddr.func (ipAddr IPAddr) String() string &#123; return fmt.Sprintf(\"%v.%v.%v.%v\", ipAddr[0], ipAddr[1], ipAddr[2], ipAddr[3])&#125;func main() &#123; hosts := map[string]IPAddr&#123; \"loopback\": &#123;127, 0, 0, 1&#125;, \"googleDNS\": &#123;8, 8, 8, 8&#125;, &#125; for name, ip := range hosts &#123; fmt.Printf(\"%v: %v\\n\", name, ip) &#125;&#125; 错误Go 程序使用 error 值来表示错误状态。 与 fmt.Stringer 类似，error 类型是一个内建接口： 123type error interface &#123; Error() string&#125; （与 fmt.Stringer 类似，fmt 包在打印值时也会满足 error。） 通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil 来进行错误处理。 123456i, err := strconv.Atoi(\"42\")if err != nil &#123; fmt.Printf(\"couldn't convert number: %v\\n\", err) return&#125;fmt.Println(\"Converted integer:\", i) error 为 nil 时表示成功；非 nil 的 error 表示失败。 Readerio 包指定了 io.Reader 接口，它表示从数据流的末尾进行读取。 Go 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。 io.Reader 接口有一个 Read 方法： func (T) Read(b []byte) (n int, err error)Read 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.EOF 错误。 示例代码创建了一个 strings.Reader 并以每次 8 字节的速度读取它的输出。","categories":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/tags/go/"}]},{"title":"go语言学习更多类型结构体,数组，切片和映射","slug":"go语言学习更多类型结构体-数组，切片和映射","date":"2018-08-07T05:35:32.000Z","updated":"2019-06-04T03:31:43.631Z","comments":true,"path":"2018/08/07/go语言学习更多类型结构体-数组，切片和映射/","link":"","permalink":"http://blog.zhouyajun.cn/2018/08/07/go语言学习更多类型结构体-数组，切片和映射/","excerpt":"指针Go拥有指针。指针保存了值的内存地址。类型*T 指向T类型值的指针。&amp;操作符会生成一个指向其操作数的指针。*操作符表示指针指向的底层值与c不同，Go没有指针运算。 12345678910111213141516package mainimport \"fmt\"func main() &#123; i, j := 42, 2701 p := &amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = &amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.Println(j) // see the new value of j&#125;","text":"指针Go拥有指针。指针保存了值的内存地址。类型*T 指向T类型值的指针。&amp;操作符会生成一个指向其操作数的指针。*操作符表示指针指向的底层值与c不同，Go没有指针运算。 12345678910111213141516package mainimport \"fmt\"func main() &#123; i, j := 42, 2701 p := &amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = &amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.Println(j) // see the new value of j&#125; 结构体一个结构体（struct）就是一个字段的集合。结合体字段使用点号来访问。结构体字段可以通过结构体指针来访问。结构体文法通过直接列出字段的值来重新分配一个结构体。使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）特殊的前缀 &amp; 返回一个指向结构体的指针。 1234567891011121314151617181920package mainimport \"fmt\"type Vertex struct &#123; X, Y int&#125;var ( v1 = Vertex&#123;1,2&#125; // has type Vertex v2 = Vertex&#123;X: 1&#125; // Y:0 is implicit v3 = Vertex&#123;&#125; // X:0 and Y:0 p = &amp;Vertex&#123;1, 2&#125; // has type *Vertex)func main() &#123; fmt.Println(v1, p, v2, v3)&#125;//返回：&#123;1 2&#125; &amp;&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125; 数组类型[n]T表示拥有n个T类型的值的数组 12//会将变量 a 声明为拥有有 10 个整数的数组。var a [10]int 数组的长度是其类型的一部分，因此数组不能改变大小。 切片类型[]T表示一个类型为T的切片12345var a = [4]int&#123; 1,2,3,4&#125;var s = a[0,2] // [1 2]var b = a[1,3] // [2 3] 切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：12345a[low : high]//它会选择一个半开区间，包括第一个元素，但排除最后一个元素。//low 默认为0//high 默认为切片的长度a[0:10] == a[:10] == a[0:] == a[:] 切片的长度就是它所包含的元素个数。切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。 1234//获取切片长度var s = []int //零值 == nillen(s) // 0cap(s) // 0 用make函数创建切片123//第二个参数为长度，第三个参数为容量a := make([]int,5)b := make([]int,0,10) 切片的切片切片可包含任何类型，甚至包括其他的切片 向切片追加元素func append( s []T，vs …T) [ ]Tappend 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。 append 的结果是一个包含原切片所有元素加上新添加元素的切片。 Rangefor 循环的range形式 可遍历切片或映射当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。可以将下标或值赋予 _ 来忽略它。 若你只需要索引，去掉 , value 的部分即可。 1234567891011121314151617181920212223242526package mainimport \"fmt\"var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;func main() &#123; for i, v := range pow &#123; fmt.Printf(\"2**%d = %d\\n\", i, v) &#125;&#125;//返回2**0 = 12**1 = 22**2 = 42**3 = 82**4 = 162**5 = 322**6 = 642**7 = 128//i = 切片 pow 的下标for i := range pow&#123;&#125;// 忽略切片下标。只取值for _, value := range pow&#123;&#125; 映射映射将键映射到值。映射的零值为 nil 。nil 映射既没有键，也不能添加键。映射的文法与结构体相似，不过必须有键名。若顶级类型只是一个类型名，你可以在文法的元素中省略它。示例：var m = map[string]int 12345678910//设置会插入值m['test'] = 111//获取值test := m['test']//删除元素delete(m,'test')//通过双赋值检测某个键是否存在：elem ,ok := m['test']m中存在 test, ok为ture,反之为falsem中存在test, elem为值，反之为 类型的零值 函数值函数也是值。它们可以像其它值一样传递。函数值可以用作函数的参数或返回值。 12345//函数作为参数func test(fn func(float64, float64)float64)float64&#123; //返回 return fn(3,4)&#125; 函数的闭包Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。","categories":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/tags/go/"}]},{"title":"mac使用配置proxychains-ng","slug":"mac使用proxychains-ng","date":"2018-08-06T08:17:12.000Z","updated":"2019-06-04T03:31:43.631Z","comments":true,"path":"2018/08/06/mac使用proxychains-ng/","link":"","permalink":"http://blog.zhouyajun.cn/2018/08/06/mac使用proxychains-ng/","excerpt":"安装proxychains-ng1brew install proxychains-ng 修改配置文件（/usr/local/etc/proxychains.conf）最后一行修改为：1086为socks5 端口，视自己的shadowsocks设置而定（shadowsocks-x默认为1080，shadowsocks-ng默认为1086） 1socks5 127.0.0.1 1086 使用方法在执行命令之前添加 ： proxychains4,如下： 1proxychains4 curl ip.cn 特别注意：mac os sierra 因为安全机制并不能成功代理！","text":"安装proxychains-ng1brew install proxychains-ng 修改配置文件（/usr/local/etc/proxychains.conf）最后一行修改为：1086为socks5 端口，视自己的shadowsocks设置而定（shadowsocks-x默认为1080，shadowsocks-ng默认为1086） 1socks5 127.0.0.1 1086 使用方法在执行命令之前添加 ： proxychains4,如下： 1proxychains4 curl ip.cn 特别注意：mac os sierra 因为安全机制并不能成功代理！ 解决办法：1.关闭SIP（不推荐）关闭sip,了解风险 2.移动执行命令例如： 123456789101112131415$ mkdir ~/proxy_bin$ cp /usr/bin/curl ~/proxy_bin//原来的$ proxychains4 curl ip.cn[proxychains] config file found: /usr/local/etc/proxychains.conf[proxychains] preloading /usr/local/Cellar/proxychains-ng/4.13/lib/libproxychains4.dylib当前 IP：114.226.157.29 来自：江苏省常州市 电信//复制的$ proxychains4 ~/proxy_bin/curl ip.cn[proxychains] config file found: /usr/local/etc/proxychains.conf[proxychains] preloading /usr/local/Cellar/proxychains-ng/4.13/lib/libproxychains4.dylib[proxychains] DLL init: proxychains-ng 4.13[proxychains] Strict chain ... 127.0.0.1:1086 ... ip.cn:80 ... OK当前 IP：107.151.181.162 来自：美国 Zenlayer 配置环境代理(推荐)123456789101112131415161718$ vim ~/.zshrc //添加如下内容(注意：1080端口必须是你的shadowsocks 的socks5 端口，不是固定)# proxy listalias proxy=&apos;export all_proxy=socks5://127.0.0.1:1080&apos;alias unproxy=&apos;unset all_proxy&apos;//使修改生效source ~/.zshrc//测试--为使用代理$ curl ip.cn当前 IP：114.226.157.29 来自：江苏省常州市 电信//使用代理$ proxy$ curl ip.cn当前 IP：107.151.181.162 来自：美国 Zenlayer// 关闭代理$ unproxy$ curl ip.cn当前 IP：114.226.157.29 来自：江苏省常州市 电信 修改修改成这样后，go get 代理成功 12alias proxy=&apos;export all_proxy=socks5://127.0.0.1:1086 &amp;&amp; export http_proxy=socks5://127.0.0.1:1086 &amp;&amp; export https_proxy=socks5://127.0.0.1:1086&apos;alias unproxy=&apos;unset all_proxy &amp;&amp; unset http_proxy &amp;&amp; unset https_proxy&apos; 参考链接-1参考链接-2","categories":[{"name":"mac","slug":"mac","permalink":"http://blog.zhouyajun.cn/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://blog.zhouyajun.cn/tags/mac/"},{"name":"proxychains-ng","slug":"proxychains-ng","permalink":"http://blog.zhouyajun.cn/tags/proxychains-ng/"}]},{"title":"go流程控制结构","slug":"go流程控制结构","date":"2018-08-06T01:30:45.000Z","updated":"2019-06-04T03:31:43.630Z","comments":true,"path":"2018/08/06/go流程控制结构/","link":"","permalink":"http://blog.zhouyajun.cn/2018/08/06/go流程控制结构/","excerpt":"go语言学习-(流程控制语句：for、if、else、switch、defer)forGo只有一种循环结构： for循环Go的for语句后面没有小括号（）大括号{}是必须的初始化语句和后置语句是可选的 123456789for a=0;a&lt;10;a++&#123;&#125;for ;a&lt;10; &#123;&#125;//上面可以去掉；就等于c语言中的whilefor a&lt;10 &#123;&#125;","text":"go语言学习-(流程控制语句：for、if、else、switch、defer)forGo只有一种循环结构： for循环Go的for语句后面没有小括号（）大括号{}是必须的初始化语句和后置语句是可选的 123456789for a=0;a&lt;10;a++&#123;&#125;for ;a&lt;10; &#123;&#125;//上面可以去掉；就等于c语言中的whilefor a&lt;10 &#123;&#125; ifif语句与for循环类似，表达式外无需小括号（），而大括号{}则是必须的。if语句可以在表达式前执行一个简单的语句。该语句申明的变量作用域仅在if之内 123456if a&lt;10 &#123;&#125;if b := 10;b&lt;10&#123;&#125; switchgo自动提供了在这些语言中的每个case后面所需的break语句。go的另一个重点的不同在于switch的case 无需为常量，且取值不必为整数。 1234567891011os := runtime.GOOS switch os &#123; case &quot;darwin&quot;: fmt.Println(&quot;OS X.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(&quot;%s.&quot;, os) &#125; 无条件的switch == switch true 12345678switch &#123; case 1: fmt.Printf(&apos;1&apos;) case 2: fmt.Printf(&apos;2&apos;) default: fmt.Printf(&apos;default&apos;)&#125; deferdefer 语句会将函数推迟到外层函数返回之后执行 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; defer fmt.Println(&quot;world&quot;) fmt.Println(&quot;hello&quot;) fmt.Println(&quot;hello111&quot;)&#125;//程序返回hellohello111world defer 栈推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;counting&quot;) for i := 0; i &lt; 10; i++ &#123; defer fmt.Println(i) &#125; fmt.Println(&quot;done&quot;)&#125;//返回countingdone9876543210","categories":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/tags/go/"}]},{"title":"go包变量和函数","slug":"go包变量和函数","date":"2018-08-05T13:44:39.000Z","updated":"2019-06-04T03:31:43.630Z","comments":true,"path":"2018/08/05/go包变量和函数/","link":"","permalink":"http://blog.zhouyajun.cn/2018/08/05/go包变量和函数/","excerpt":"GO语言学习-(包，变量，函数)包每个go程序都有包构成。程序从main包开始运行。按照约定：包名与导入路径的最后一个元素一只。 导入12345678//分组导入(更好)import( &quot;fmt&quot; &quot;math&quot;)//多条导入import fmtimport math","text":"GO语言学习-(包，变量，函数)包每个go程序都有包构成。程序从main包开始运行。按照约定：包名与导入路径的最后一个元素一只。 导入12345678//分组导入(更好)import( &quot;fmt&quot; &quot;math&quot;)//多条导入import fmtimport math 导出如果一个名字以大写字母开头，那么它就是已导出的。 函数函数可以没有参数，或者多个参数，注意参数类型在参数名之后。小括号后面的类型是返回值类型 123func test(x int,y int)int&#123;&#125; 当连续两个或以上参数类型相同时，除连续相同的最后一个参数，其他参数的类型都可以省略,返回值命名类型也一样 123func test(x,y int)int&#123;&#125; 注意：函数可以返回多个值 123func test(x ,y int)(int,int)&#123; return x,y&#125; 注意：函数的返回值可被命名 12345func test(sum)(x int ,y int)&#123; x = sum -1 y = sum -x return &#125; 变量123456var x intvar y stringvar z boolvar a,b,c boolvar a,b,c int = 1,2,3var a int = 1 声明变量语法块用法： 1234var ( a int = 1 b,c int = 3,4) 在函数中，可以使用短变量申明： 1234567func test(x ,y int)int&#123; c := x+y return c&#125;func main()&#123; test :=1&#125; 没有明确初始值的变量声明会被赋予它们的零值数值型 - 0布尔类型 - false字符串为 - “”（空字符串） 基本类型 bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 float32 float64 complex64 complex128 类型转换T(v)int(12.0)float64(1212) 类型推导当指定一个变量而未指定变量类型时，变量的类型由右值推导而出。 12345var a = 1 // a 为intfunc main()&#123; b := &quot;12112&quot; // b为string c := 1.002 // float64&#125; 常量const 关键字定义常量常量可以是字符，字符串，数值，布尔值 1const Pi float64 = 3.1415 一个未指定类型的常量由上下文来决定其类型","categories":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/tags/go/"}]},{"title":"go代码工作空间","slug":"go代码工作空间","date":"2018-08-05T13:44:12.000Z","updated":"2019-06-04T03:31:43.630Z","comments":true,"path":"2018/08/05/go代码工作空间/","link":"","permalink":"http://blog.zhouyajun.cn/2018/08/05/go代码工作空间/","excerpt":"","text":"go语言学习-go代码工作空间go代码工作空间go代码必须放置在工作空间内，它其实就是一个目录，其中包含三个子目录。 1. src 目录目录包含Go的源文件，它们被组织成包（每个目录都对应一个包） 1export GOPATH=~/workspace/go 2. pkg 目录pkg 目录包含包对象 3. bin 目录bin目录包含可执行命令 4. 将bin目录加入系统path1export PATH=$path:$GOPATH/bin 这样在任何地方都可执行go可执行文件 5. go 环境查看123456789101112131415161718192021222324$ go envGOARCH=\"amd64\"GOBIN=\"\"GOCACHE=\"/Users/zyj/Library/Caches/go-build\"GOEXE=\"\"GOHOSTARCH=\"amd64\"GOHOSTOS=\"darwin\"GOOS=\"darwin\"GOPATH=\"/Users/zyj/workspace/go\"GORACE=\"\"GOROOT=\"/usr/local/go\"GOTMPDIR=\"\"GOTOOLDIR=\"/usr/local/go/pkg/tool/darwin_amd64\"GCCGO=\"gccgo\"CC=\"clang\"CXX=\"clang++\"CGO_ENABLED=\"1\"CGO_CFLAGS=\"-g -O2\"CGO_CPPFLAGS=\"\"CGO_CXXFLAGS=\"-g -O2\"CGO_FFLAGS=\"-g -O2\"CGO_LDFLAGS=\"-g -O2\"PKG_CONFIG=\"pkg-config\"GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/q1/_vk1dvf156701f1zfhgvv5rm0000gp/T/go-build170346034=/tmp/go-build -gno-record-gcc-switches -fno-common\"","categories":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://blog.zhouyajun.cn/tags/go/"}]},{"title":"shadowsocks自定义代理规则user-rule设置方法","slug":"shadowsocks自定义代理规则user-rule设置方法","date":"2018-08-03T01:44:51.000Z","updated":"2019-06-04T03:31:43.630Z","comments":true,"path":"2018/08/03/shadowsocks自定义代理规则user-rule设置方法/","link":"","permalink":"http://blog.zhouyajun.cn/2018/08/03/shadowsocks自定义代理规则user-rule设置方法/","excerpt":"","text":"最新版本的shadowsocks支持用户自定义代理规则，更新到最新的版本的shadowsocks后， 在shadowsocks文件夹内会有一个user-rule.txt文档，如果用户需要添加自定义代理规则，只需要编辑user-rule.txt文件。自定义代理规则设置语法与GFWlist相同，即Adblock Plus filters explained。 规则说明1. 通配符支持，如*.baidu.com/,实际书写时可省略 *号1*.baidu.com 2. 正则表达式支持，以\\开始和结束1\\[\\w]+:Wexample.com\\ 3.例外规则(满足@@后规则的地址不使用代理)1@@*.example.com/* 4.用|符号，匹配地址开始和结束12|http:example.comexample.com| 5.||标记，匹配协议1||example.com 6.注释！1!Comment 注意：user-rule.txt中的规则并不能直接被shadowsocks使用，如要添加到user-rule.txt中的规则生效，你还要执行下面重要的一步：更新本地的PAC，更新后user-rule.txt中的自定义规则会添加到PAC.txt文件内。（备注：每次编辑完user-rule.txt后，均需执行“从GFWList更新本地PAC”，使本次规则也生效。）","categories":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://blog.zhouyajun.cn/categories/shadowsocks/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://blog.zhouyajun.cn/tags/shadowsocks/"}]},{"title":"git命令复习","slug":"git命令复习","date":"2018-07-29T01:26:21.000Z","updated":"2019-06-04T03:31:43.630Z","comments":true,"path":"2018/07/29/git命令复习/","link":"","permalink":"http://blog.zhouyajun.cn/2018/07/29/git命令复习/","excerpt":"git 命令复习参考链接：Git Cheat Sheet 中文版 配置 命令 说明 git config --list 列出当前配置 git config --local --list 列出当前仓库配置 git config --global --list 列出全局配置 git config --system --list 列出系统配置 git config --global user.name &quot;zyj&quot; 设置用户名 git config --global user.email 设置用户的邮箱","text":"git 命令复习参考链接：Git Cheat Sheet 中文版 配置 命令 说明 git config --list 列出当前配置 git config --local --list 列出当前仓库配置 git config --global --list 列出全局配置 git config --system --list 列出系统配置 git config --global user.name &quot;zyj&quot; 设置用户名 git config --global user.email 设置用户的邮箱 #### 配置文件 文件地址 说明 :——– :——– &lt;repo&gt;/.git/config Repository配置对应的配置文件路径[–local]： ~/.gitconfig 用户全局配置对应的配置文件路径[–global]： /etc/gitconfig 系统配置对应的配置文件路径[–local]：(不一定存在) 创建复制一个已创建的仓库：1234# 通过ssh$ git clone ssh://user@domain.com/repo.git# 通过HTTP$ git clone http://domain.com/user/repo.git 创建一个本地新仓库1git init 本地修改 命令 说明 git status 显示工作路径下已修改的文件 git diff 显示与上次提交版本的不同 git add . 把当前所有修改添加到下次提交中 git add -p &lt;file&gt; 把对某个文件的修改添加到下次提交中 git commit -a 提交本地的所有修改 git commit 提交之前已标记的变化 git commit -m &#39;message here&#39; 提交之前已标记的变化并附加消息提交 git commit --date=&quot;date –date=’n day ago’&quot; -am &quot;Commit Message&quot; 提交，并将提交时间设置为之前的某个日期 #### 修改上次提交 命令 说明 :——– :——– git commit --amend 修改上次提交,既可以对上次提交的内容进行修改，也可以修改提交说明 git commit --amend --no-edit 编辑器会弹出上一次提交的信息，加入–no-edit标记会修复提交但不修改提交信息 git commit --amend --author=&quot;username &lt;email&gt;&quot; 修改用户信息 git push --force-with-lease origin master 修改提交强制同步到远程 保存当前修改，并返回上一次干净的仓库 命令 说明 git stash,git stash save 保存当前的修改 git stash list 暂存的内容列表 git stash apply 重新存储最后一次缓存的内容，当前的修改保存到当前分支，缓存标签仍然存在于 git stash list列表中 git stash apply 0 重新存储编号为0的内容，当前的修改保存到当前分支，缓存标签仍然存在于 git stash list列表中 git stash pop 重新存储最后一次缓存的内容，当前的修改保存到当前分支，删除git stash list 列表中的存储编号 git stash pop 1 重新存储编号为0的缓存的内容，当前的修改保存到当前分支，删除git stash list 列表中的存储编号 git stash show [stash] 显示stash和上一个提交点的差异 git stash drop [0] 删除编号为0的暂存 git stash clear 清空所有的暂存列表 搜索 命令 说明 git grep &quot;hello&quot; 从当前目录的所有文件中查找文本内容 git grep &quot;hello&quot; v2.5 从某一版本中搜索文本 #### 提交历史 命令 说明 :——– :——– git log 显示所有的提交记录,（显示hash,作者信息，提交的标题和时间） git log --oneline git log --author=&quot;zyj&quot; git log -p &lt;file&gt; 显示某个文件的所有修改 git log origin/master --left-right 显示远端的提交历史 git blame &lt;filename&gt; 查看某个文件的修改历史 git blame -L &lt;start&gt;,&lt;end&gt; &lt;filename&gt; 查看某个文件的修改历史，并指定开始行和结束行 git reflog show 显示所有分支的（包括远端）的提交历史 git reflog delete 删除reflog 分支与标签 命令 说明 git branch 列出所有的分支 git branch -r 列出所有的远端分支 git checkout &lt;branch&gt; 切换分支 git checkout -b &lt;branch&gt; 创建并切换到新分支 git branch &lt;new-branch&gt; 基于当前分支创建新分支 git branch --track &lt;new-branch&gt; &lt;remote-branch&gt; 基于远程分支创建新的可追溯的分支 git branch -d &lt;branch&gt; 删除本地分支 git branch -D &lt;branch&gt; 强制删除一个分支 git tag &lt;tag_name&gt; 给当前版本打标签，没有说明 git tag -a &lt;tag_name&gt; 给当前版本打标签，并附上说明 git tag -l 查看所有的标签列表 git tag -d &lt;tag_name&gt; 删除一个本地标签 git push origin :refs/tags/&lt;tagname&gt; 删除一个远端标签 git push origin v1.0 发布一个标签到origin git push --tags 发布本地所有的标签到远端 更新与发布 git remote -v 显示所有的远端分支 123$ git remote -vorigin git@gitee.com:yajun0310/blog.git (fetch)origin git@gitee.com:yajun0310/blog.git (push) git remote show &lt;remote&gt;显示远端的详细信息 1234567891011121314$ git remote show origin* remote origin Fetch URL: git@gitee.com:yajun0310/blog.git Push URL: git@gitee.com:yajun0310/blog.git HEAD branch: master Remote branches: develop tracked master tracked Local branches configured for &apos;git pull&apos;: develop merges with remote develop master merges with remote master Local refs configured for &apos;git push&apos;: develop pushes to develop (up to date) master pushes to master (up to date) git remote add &lt;remote&gt; &lt;url&gt;添加新的远端 1git remote add origin2git@gitee.com:yajun0310/blog.git git fetch &lt;remote&gt;下载远程端版本，但不合并到head中 123$ git fetch origin masterFrom gitee.com:yajun0310/blog * branch master -&gt; FETCH_HEAD git remote pull &lt;remote&gt; &lt;url&gt;下载远程版本，并自动与head版本合并 git pull origin master将远程端版本合并到本地版本中 1234$ git pull origin masterFrom gitee.com:yajun0310/blog * branch master -&gt; FETCH_HEADAlready up to date. git pull --rebase &lt;remote&gt; &lt;branch&gt;以rebase方式将远程分支与本地分支合并 git push &lt;remote&gt; &lt;branch&gt;推送到远程branch分支，不存在branch分支会自动新建branch分支 git push -u &lt;remote&gt; &lt;branch&gt;操作同上，不同的是会自动关联上远程，git push 操作默认推送branch分支 删除远程分支since:1.5git push &lt;remote&gt; :&lt;branch&gt;since1.7git push &lt;remote&gt; --delete &lt;branch&gt; 1234567891011** since1.5.0 **$ git push origin :testremote: Powered by Gitee.comTo gitee.com:yajun0310/blog.git - [deleted] test**since 1.7.0**$ git push origin --delete testremote: Powered by Gitee.comTo gitee.com:yajun0310/blog.git - [deleted] test 合并与重置 git merge &lt;branch&gt; 将分支合并到当前分支中 git rebase &lt;branch&gt;将分支合并到当前分支（衍合） git rebase -i &lt;branch&gt; 交互式衍合 git rebase --continue 衍合继续 git rebase --abort取消衍合 git mergetool 使用配置好的merge tool 解决冲突 在编辑器手动解决冲突后。标记为已解决12git add &lt;resolved-file&gt;git rm &lt;resolved-file&gt; 撤销 git reset --hard HEAD 放弃工作目录下的所有修改 git reset HEAD 移除缓存区的所有文件（撤销上次 git add） git checkout HEAD &lt;file&gt;放弃某个文件的所有本地修改 git reset --hard &lt;commit&gt;将head重置到指定的版本，并抛弃到版本之后的所有修改 git revert &lt;commit&gt;重置一个提交，（通过创建一个截然不同的新提交） git reset --hard origin/master 用远端分支强制覆盖本地分支 git reset &lt;commit&gt; 将head重置到某一次提交，并将之后的修改标记为未添加到的缓冲区的修改 git reset --keep &lt;commit&gt;将HEAD重制到某一次提交，并保留未提交的本地修改 删除添加.gitignore文件前错误提交的文件123git rm -r --cached .git add .git commit -m &quot;remove aa file&quot;","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://blog.zhouyajun.cn/tags/git/"}]},{"title":"小程序文件类型介绍","slug":"小程序文件类型介绍","date":"2018-07-19T06:28:58.000Z","updated":"2019-06-04T03:31:43.630Z","comments":true,"path":"2018/07/19/小程序文件类型介绍/","link":"","permalink":"http://blog.zhouyajun.cn/2018/07/19/小程序文件类型介绍/","excerpt":"1. 文件类型 .json 后缀的JSON 配置文件 .wxml 后缀的 WXML模版文件 .wxss 后缀的WXSS样式文件 .js 后缀的JS脚本逻辑文件 注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。 JSON配置小程序全局配置文件 app.jsonapp.json是对当前小程序的全局配置，包括了小程序的所有页面路径，界面表现，网络超时时间，底部tab等。 属性 类型 必填 描述 pages string Array 是 设置页面路径 windows object 否 设置默认页面的窗口表现 tabBar object 否 设置底部tab的表现 networkTimeout object 否 设置网络超时时间 debug boolean 否 设置是否开启debug模式","text":"1. 文件类型 .json 后缀的JSON 配置文件 .wxml 后缀的 WXML模版文件 .wxss 后缀的WXSS样式文件 .js 后缀的JS脚本逻辑文件 注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。 JSON配置小程序全局配置文件 app.jsonapp.json是对当前小程序的全局配置，包括了小程序的所有页面路径，界面表现，网络超时时间，底部tab等。 属性 类型 必填 描述 pages string Array 是 设置页面路径 windows object 否 设置默认页面的窗口表现 tabBar object 否 设置底部tab的表现 networkTimeout object 否 设置网络超时时间 debug boolean 否 设置是否开启debug模式 pages 属性接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。 文件名不需要写文件后缀，因为框架会自动去寻找路径下 .json, .js, .wxml, .wxss 四个文件进行整合。 windows属性|属性 | 类型 | 默认值 | 描述 || :——– | ——–: | :——–: | :——– |:——– || navigationBarBackgroundColor |HexColor|#000000|导航栏背景颜色，如”#000000”||navigationBarTextStyle|string|white|导航栏标题颜色，仅支持 black/white ||navigationBarTitleText|string||导航栏标题文字内容||navigationStyle|string|default|导航栏样式，仅支持 default/custom。custom 模式可自定义导航栏，只保留右上角胶囊状的按钮,微信版本6.6.0| |backgroundColor|HexColor|#ffffff|下拉窗口的背景色||backgroundTextStyle|string|dark|下拉loading的样式，仅支持dark/light||backgroundColorTop|string|#ffffff|顶部窗口的背景色，仅ios支持,微信版本6.5.16| |backgroundColorBottom|string|#ffffff|底部窗口的背景色，仅ios支持,微信版本6.5.16| |enablePullDownRefresh|Boolean|false|是否开启下拉刷新||onReachBottomDistance|Number|50|页面上拉触底事件触发时距页面底部距离，单位为px| 注：HexColor（十六进制颜色值），如”#ff00ff” 注：navigationStyle 只在 app.json 中生效。开启 custom 后，低版本客户端需要做好兼容。开发者工具基础库版本切到 1.7.0（不代表最低版本，只供调试用） 可方便切到旧视觉 tabBar属性如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。注意： 当设置position为top时，将不会显示icon tabBar中的list是一个数组，只能配置最少2个，最多5个,tab按数组的顺序排序 属性说明： 属性 类型 必填 默认中 描述 color HexColor 是 tab上文字默认颜色 selectColor HexColor 是 tab上文字选中时的颜色 backgroundColor HexColor 是 tab 的背景色 borderStyle string 否 black tabbar上边框的颜色， 仅支持 black/white list Array 是 tab 的列表，详见 list 属性说明，最少2个、最多5个 tab position string 否 bottom 可选值bottom、top 其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下： 属性 类型 必填 描述 pagePath string 是 页面路径，必须在pages中先定义 text string 是 tab上按钮文字 iconPath string 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效，不支持网络图片 selectedIconPath string 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 networkTimeout 属性可以设置各种网络请求的超时时间。 属性说明： 属性 类型 必填 描述 request Number 否 wx.request的超时时间，单位毫秒，默认为：60000 connectSocket Number 否 wx.connectSocket的超时时间，单位毫秒，默认为：60000 uploadFile Number 否 wx.uploadFile的超时时间，单位毫秒，默认为：60000 downloadFile Number 否 wx.downloadFile的超时时间，单位毫秒，默认为：60000 debug属性可以在开发者工具中开启debug模式，在开发者工具的控制面板，调试信息以 info 的形式给出，其信息有page 的注册，页面路由，数据更新，事件触发。可以帮助开发者快速定位一些常见的问题。 page.json每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键。 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如”#000000” navigationBarTextStyle string white 导航栏标题颜色，仅支持 black/white navigationBarTitleText string 导航栏标题文字内容 navigationStyle string default 导航栏样式，仅支持 default/custom。custom 模式可自定义导航栏，只保留右上角胶囊状的按钮,微信版本6.6.0 backgroundColor HexColor #ffffff 下拉窗口的背景色 backgroundTextStyle string dark 下拉loading的样式，仅支持dark/light backgroundColorTop string #ffffff 顶部窗口的背景色，仅ios支持,微信版本6.5.16 backgroundColorBottom string #ffffff 底部窗口的背景色，仅ios支持,微信版本6.5.16 enablePullDownRefresh Boolean false 是否开启下拉刷新 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px disableScroll Boolean false 设置为 true 则页面整体不能上下滚动；只在 page.json 中有效，无法在 app.json 中设置该项","categories":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/tags/小程序/"},{"name":"微信","slug":"微信","permalink":"http://blog.zhouyajun.cn/tags/微信/"}]},{"title":"小程序开发快捷键","slug":"小程序开发快捷键","date":"2018-07-18T01:45:45.000Z","updated":"2019-06-04T03:31:43.630Z","comments":true,"path":"2018/07/18/小程序开发快捷键/","link":"","permalink":"http://blog.zhouyajun.cn/2018/07/18/小程序开发快捷键/","excerpt":"","text":"小程序开发工具快捷键界面快捷键 快捷键 说明 ⌘+⇧+T 显示/隐藏界面工具栏 ⌘+⇧+D 显示/隐藏模拟器 ⌘+⇧+E 显示/隐藏编辑器 ⌘+⇧+I 显示/隐藏控制台 ⌘+⇧+M 显示/隐藏目录树 工具快捷键 快捷键 说明 ⌘+⇧+P 预览，自动预览 ⌘+⇧+U 上传代码 ⌘+B 编译 ⌘+R 刷新 编辑器快捷键 快捷键 说明 ⌥+⇧+F 格式化代码 ⌘+P 跳转文件 ⌘+E 最近打开的文件","categories":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/tags/小程序/"},{"name":"微信","slug":"微信","permalink":"http://blog.zhouyajun.cn/tags/微信/"}]},{"title":"扫码打开小程序指南","slug":"扫码打开小程序指南","date":"2018-07-17T01:25:58.000Z","updated":"2019-06-04T03:31:43.629Z","comments":true,"path":"2018/07/17/扫码打开小程序指南/","link":"","permalink":"http://blog.zhouyajun.cn/2018/07/17/扫码打开小程序指南/","excerpt":"参考文档：扫普通二维码打开小程序 扫普通链接二维码打开小程序为了方便小程序开发者更便捷地推广小程序，兼容线下已有的二维码，微信公众平台开放扫描普通链接二维码跳转小程序能力。 功能介绍普通链接二维码，是指开发者使用工具对网页链接进行编码后生成的二维码。 线下商户可不需更换线下二维码，在小程序后台完成配置后，即可在用户扫描普通链接二维码时打开小程序，使用小程序的功能。 对于普通链接二维码，目前支持使用微信“扫一扫”或微信内长按识别二维码跳转小程序。","text":"参考文档：扫普通二维码打开小程序 扫普通链接二维码打开小程序为了方便小程序开发者更便捷地推广小程序，兼容线下已有的二维码，微信公众平台开放扫描普通链接二维码跳转小程序能力。 功能介绍普通链接二维码，是指开发者使用工具对网页链接进行编码后生成的二维码。 线下商户可不需更换线下二维码，在小程序后台完成配置后，即可在用户扫描普通链接二维码时打开小程序，使用小程序的功能。 对于普通链接二维码，目前支持使用微信“扫一扫”或微信内长按识别二维码跳转小程序。 开放范围企业、媒体、政府及其他组织类型小程序。注意：个人小程序不支持 二维码跳转规则注意：从2017年5月开始，微信客户端支持二维码规则根据“子路径匹配”。如原有现在二维码链接为 http://www.qq.com/a/123456 ,其中12345为业务参数，则可配置规则 http://www.qq.com/a/ 实现扫码打开小程序。 微信客户端扫码将按以下匹配规则控制跳转： 二维码链接的协议、域名与已配置的二维码规则一致。 二维码链接属于后台配置的二维码规则的子路径。(如需支持子路径匹配，请确认后台配置的二维码规则以“/”结尾) 如果二维码规则包含参数，链接“？”后为参数部分，参数要求前缀匹配 常见匹配错误类型： 后台配置的二维码规则 线下二维码完整链接 错误原因 http://www.qq.com/a/b https://www.qq.com/a/b 协议不一致 https://www.qq.com/a/b https://www.weixin.qq.com/a/b 域名不一 https://www.qq.com/a/b?id=123 https://www.qq.com/a/b?id=132 参数不满足前缀匹配 https://www.qq.com/a/b https://www.qq.com/a/bc 不属于子路径 https://www.qq.com/a/b https://www.qq.com/a/b/123 规则没有以“/”结尾，不支持子路径匹配 二维码内容获取在小程序后台配置二维码跳转小程序规则之后即可使用微信（6.5.6及其以上客户端版本）扫码打开小程序。 二维码链接内容会以参数q的形式带给页面，在onLoad事件中提取”q”参数并自行UrlDecode一次，即可获取原二维码的完整内容。 配置流程登录小程序后台，进入“设置-开发设置-扫普通链接二维码打开小程序”，开启功能后即可配置二维码规则。 二维码规则根据二维码跳转规则，开发者需要填写跳转小程序的二维码规则要求如下： 二维码规则的域名必须通过ICP 备案的验证。 支持http、https、ftp开头的链接 一个小程序账号可配置不多于10个的二维码前缀规则。 前缀占用规则开发者可选择是否占用符合二维码匹配规则的所有子规则。如选择占用，则其他帐号不可申请使用满足该前缀匹配规则的其他子规则。 如：若开发者A配置二维码规则：https://wx.qq.com/mp?id=123，并选择“占用所有子规则“，其他开发者将不可以配置满足前缀匹配的子规则如https://wx.qq.com/mp?id=1234。 注意：如提示“此规则已被占用”，请联系对应小程序开发者沟通解决。 校验文件下载随机校验文件，并将文件上传至服务器指定位置的目录下，方可通过所属权校验。 验证文件放置规则： 放置于URL中声明的最后一级子目录下，若无子目录，则放置于host所属服务器的顶层目录下。请根据页面提示将验证文件放置在指定的目录下。 小程序功能页面配置扫描二维码后打开的小程序功能页面路径，如：pages/index/index。 测试调试开发者可对已配置的二维码规则进行测试和调试。测试仅对指定的测试链接和测试范围内的微信用户生效，其他用户扫码后跳转网页，不影响全网用户正常使用。在二维码规则发布后，开发者仍然可以选择在指定版本（开发版/体验版/线上版本）下测试。 测试范围开发者可根据开发进度选择在开发板/体验版/线上版本测试“普通二维码跳转小程序”的功能。 测试链接填写符合二维码前缀匹配规则的二维码完整链接用于测试，如包括参数，请完整填写。 一个规则可以填写不多于5个测试链接，可多次修改。若二维码与测试链接匹配，且用户微信号是小程序指定的管理员/开发者/体验者，将打开指定版本的小程序。 发布测试完成后开发者可将二维码跳转规则发布现网，发布后扫描所有符合匹配规则的二维码，将跳转至指定的小程序页面。 注意： 为确保用户体验，小程序必须先发布代码才可以发布二维码跳转规则。 一个小程序帐号一个月可发布不多于20次二维码跳转规则。","categories":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/tags/小程序/"},{"name":"微信","slug":"微信","permalink":"http://blog.zhouyajun.cn/tags/微信/"}]},{"title":"小程序客服功能使用指南","slug":"小程序客服功能使用指南","date":"2018-07-16T13:33:15.000Z","updated":"2019-06-04T03:31:43.629Z","comments":true,"path":"2018/07/16/小程序客服功能使用指南/","link":"","permalink":"http://blog.zhouyajun.cn/2018/07/16/小程序客服功能使用指南/","excerpt":"客服消息入口（用户给客服发消息） 小程序内：开发者在小程序内添加客服消息按钮组件，用户在小程序内唤起客服会话页面，给小程序发消息。 已使用过小程序客服消息会聚合显示在微信会话“小程序客服消息”内，用户可以在小程序外查看历史客服消息，并给小程序发消息。 下发条件说明（客服给小程序用户发消息）当用户和小程序客服产生特定动作的交互时，小程序可向用户下发客服消息。目前允许的动作列表如下，不同动作触发后，允许下发消息条数和下发时限不同。下发条数达到上限后，会返回错误码。 用户动作 允许下发条数限制 下发时限 用户发送消息 5条 48小时 注意：可发送客服消息数量不累加，上述动作会触发效法条数和下发时限的更新。","text":"客服消息入口（用户给客服发消息） 小程序内：开发者在小程序内添加客服消息按钮组件，用户在小程序内唤起客服会话页面，给小程序发消息。 已使用过小程序客服消息会聚合显示在微信会话“小程序客服消息”内，用户可以在小程序外查看历史客服消息，并给小程序发消息。 下发条件说明（客服给小程序用户发消息）当用户和小程序客服产生特定动作的交互时，小程序可向用户下发客服消息。目前允许的动作列表如下，不同动作触发后，允许下发消息条数和下发时限不同。下发条数达到上限后，会返回错误码。 用户动作 允许下发条数限制 下发时限 用户发送消息 5条 48小时 注意：可发送客服消息数量不累加，上述动作会触发效法条数和下发时限的更新。 调用客服消息接口发送客服消息当用户给小程序客服发消息，微信服务器将消息的数据包post到开发者填写的url,开发者收到请求后可以调用接口进行异步恢复。 注意：一旦小程序的客服消息权限已授权给第三方平台，则所有的客服消息将发送给第三方平台，不再推送到开发者的服务器或网页版客服工具。 填写消息推送配置登录小程序，在“设置-开发设置-消息推送”启用消息推送功能并完成相关信息配置（包括服务器地址、Token、及加密方式等）。 接口调用小程序客服消息API文档地址 网页版客服工具地址：网页版客服工具若小程序没有启用消息推送，则用户发送的消息将会被转发至网页版客服工具，客服人员可在网页版客服工具中接入并回复用户。 如小程序的客服消息权限集已授权给第三方平台，则所有的客服消息将推送到第三方平台的服务器，不再推送到开发者的服务器或推送到网页版客服工具。 注意：“用户通过客服消息按钮进入会话”事件将不会转发至网页版客服工具。 绑定客服人员使用网页版客服工具前，小程序管理员需在小程序后台完成客服人员的绑定。目前小程序支持绑定不多于100个客服人员。 使用规范小程序客服消息使用除必须遵守微信小程序平台运营规范外，还不能违反以下规则，包括但不限于： 不允许恶意诱导用户进行可能触发客服消息下发的操作，以达到可向用户下发客服消息目的 不允许恶意骚扰，下发与用户发送的消息没有关联的、对用户造成骚扰的消息 不允许恶意营销，下发内容涉嫌虚假夸大、违法类营销信息 不允许使用客服消息向用户下发虚假、色情、暴力等违反国家法律规定的信息","categories":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/tags/小程序/"},{"name":"微信","slug":"微信","permalink":"http://blog.zhouyajun.cn/tags/微信/"}]},{"title":"小程序绑定微信开放平台","slug":"小程序绑定微信开放平台","date":"2018-07-16T12:34:49.000Z","updated":"2019-06-04T03:31:43.629Z","comments":true,"path":"2018/07/16/小程序绑定微信开放平台/","link":"","permalink":"http://blog.zhouyajun.cn/2018/07/16/小程序绑定微信开放平台/","excerpt":"参考文档：小程序绑定微信开放平台账号 绑定微信开放平台的好处小程序绑定微信开放平台帐号后，可与帐号下的其他移动应用、网站应用及公众号打通，通过UnionID机制满足在多个应用和公众号之间统一用户帐号的需求。","text":"参考文档：小程序绑定微信开放平台账号 绑定微信开放平台的好处小程序绑定微信开放平台帐号后，可与帐号下的其他移动应用、网站应用及公众号打通，通过UnionID机制满足在多个应用和公众号之间统一用户帐号的需求。 UnionID机制说明：如果开发者拥有多个移动应用，可通过UnionID来区分用户的唯一性，因为只要是同一个微信开放平台账号下的移动应用，网站应用和公众账号（包括小程序），用户的UnionID是相同的。用户的UnionID可通过获取用户信息接口获取。 绑定微信开发平台的步骤：1. 微信开放平台绑定公众号注意：微信开发平台账号必须完成开发者资质认证才可以绑定小程序登录微信开放平台-&gt;管理中心-&gt;公众账号-&gt;绑定公众账号 2. 微信公众号关联小程序公众号关联小程序后，将可在图文消息，自定义菜单，模版消息等功能中使用小程序。 管理规则： 所有公众号都可以关联小程序 一个公众号可关联10个同主体的小程序，3个不同主体的小程序 一个小程序可以被500个公众号关联 公众号一个月可新增关联小程序13次，小程序一个月可新增关联500次 关联流程：登录公众账号后台-&gt;小程序-&gt;小程序管理-&gt;添加-&gt;关联小程序","categories":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/tags/小程序/"},{"name":"微信","slug":"微信","permalink":"http://blog.zhouyajun.cn/tags/微信/"}]},{"title":"小程序微信认证微信支付申请注意","slug":"小程序微信认证微信支付申请注意","date":"2018-07-16T12:15:58.000Z","updated":"2019-06-04T03:31:43.629Z","comments":true,"path":"2018/07/16/小程序微信认证微信支付申请注意/","link":"","permalink":"http://blog.zhouyajun.cn/2018/07/16/小程序微信认证微信支付申请注意/","excerpt":"","text":"小程序申请微信认证 政府、媒体、其他组织类型账号 必须通过微信认证 企业类型账号 可以根据需要是否申请微信认证 个人类型账号 暂不支持微信认证 认证入口：登录小程序-设置-基本设置-微信认证-详情 小程序申请微信支付注意：已认证的小程序可申请微信支付","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/tags/小程序/"},{"name":"微信","slug":"微信","permalink":"http://blog.zhouyajun.cn/tags/微信/"}]},{"title":"小程序开发前准备","slug":"小程序开发前准备","date":"2018-07-12T13:53:04.000Z","updated":"2019-06-04T03:31:43.629Z","comments":true,"path":"2018/07/12/小程序开发前准备/","link":"","permalink":"http://blog.zhouyajun.cn/2018/07/12/小程序开发前准备/","excerpt":"","text":"小程序开发前准备参考文档：小程序开发前准备注意： 完成注册后，微信小程序信息完善步骤和开发可同步进行(已经存在appId) 绑定开发者绑定入口：登录微信公众平台小程序，进入用户身份-&gt;开发者，新增绑定开发者 主体类型 开发者数量 体验者数量 个人小程序 5 10 未认证的组织类型小程序 10 20 已认证小程序 20 40 获取appID","categories":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/tags/小程序/"}]},{"title":"小程序注册注意事项","slug":"小程序注册注意事项","date":"2018-07-11T03:16:24.000Z","updated":"2019-06-04T03:31:43.629Z","comments":true,"path":"2018/07/11/小程序注册注意事项/","link":"","permalink":"http://blog.zhouyajun.cn/2018/07/11/小程序注册注意事项/","excerpt":"小程序注册注意事项参考资料： 微信小程序接入指南 主体账号类型说明 账号主体 说明 个人 18岁以上有国内身份信息的微信实名用户 企业 企业、分支机构、企业相关品牌 企业(个体工商户) 个体工商户 政府部门 国内、各级、各类政府机构、事业单位、具有行政职能的社会组织等。目前主要覆盖公安机构、党团机构、司法机构、交通机构、旅游机构、工商税务机构、市政机构等。 媒体 报纸、杂志、电视、电台、通讯社、其他等 其他组织 不属于政府、媒体、企业或个人的类型","text":"小程序注册注意事项参考资料： 微信小程序接入指南 主体账号类型说明 账号主体 说明 个人 18岁以上有国内身份信息的微信实名用户 企业 企业、分支机构、企业相关品牌 企业(个体工商户) 个体工商户 政府部门 国内、各级、各类政府机构、事业单位、具有行政职能的社会组织等。目前主要覆盖公安机构、党团机构、司法机构、交通机构、旅游机构、工商税务机构、市政机构等。 媒体 报纸、杂志、电视、电台、通讯社、其他等 其他组织 不属于政府、媒体、企业或个人的类型 关于主体验证注意： 未验证通过的主体账户，部分功能受影响 主体信息一旦确认提交，不能修改企业用户（包括个体工商户） 通过向腾讯公司小额打款验证，验证成功，钱会原路退回 选择对公打款的用户，请根据页面提示，向指定的收款帐号汇入指定金额。 注意：请在10天内完成汇款，否则将注册失败 微信认证，费用300,需要1-5个工作日审核政府、媒体、其他组织类型帐号 必须通过微信认证验证主体身份 关于管理员信息注意： 一个身份证号码最多只能注册5个小程序 一个手机号最多只能注册5个小程序","categories":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://blog.zhouyajun.cn/tags/小程序/"}]},{"title":"冯·诺依曼结构","slug":"诺依曼结构","date":"2018-06-26T09:41:46.000Z","updated":"2019-06-04T03:31:43.628Z","comments":true,"path":"2018/06/26/诺依曼结构/","link":"","permalink":"http://blog.zhouyajun.cn/2018/06/26/诺依曼结构/","excerpt":"冯·诺依曼（现代计算机之父）IAS计算机（1951年完成）冯·诺依曼结构 重要思想：存储程序 工作方式：任何要计算机完成的工作都要先被编写成程序，然后将程序和原始数据送入主存并启动执行。一旦程序被启动，计算机应能在不需操作人员干预下，自动完成逐条取出指令和执行指令的任务","text":"冯·诺依曼（现代计算机之父）IAS计算机（1951年完成）冯·诺依曼结构 重要思想：存储程序 工作方式：任何要计算机完成的工作都要先被编写成程序，然后将程序和原始数据送入主存并启动执行。一旦程序被启动，计算机应能在不需操作人员干预下，自动完成逐条取出指令和执行指令的任务 注： 几乎现代所有的通用计算机大都采用了冯诺伊曼结构，因此，IAS计算机是现代计算机的原型机 冯·诺依曼结构的主要思想计算机组成 输入设备 控制器 存储器 运算器 输出设备 各基本部件的功能 存储器 不仅能够存放数据，而且也能够存放指令，形式上两者没有区别，但计算机应能区分数据还是指令 控制器 应能自动取出指令来执行 运算器 应能进行加／减／乘／除四种基本算数运算，并且也能进行一些逻辑运算和附加运算 操作人员可以通过输入设备、输出设备和主机进行通信 内部已二进制表示指令和数据每条指令由操作码和地址码两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序 采用 存储程序 工作方式","categories":[{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"http://blog.zhouyajun.cn/categories/深入理解计算机系统/"}],"tags":[{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"http://blog.zhouyajun.cn/tags/深入理解计算机系统/"}]},{"title":"计算机的基本部件","slug":"计算机的基本部件","date":"2018-06-26T02:00:33.000Z","updated":"2019-06-04T03:31:43.628Z","comments":true,"path":"2018/06/26/计算机的基本部件/","link":"","permalink":"http://blog.zhouyajun.cn/2018/06/26/计算机的基本部件/","excerpt":"计算机的基本部件1. CPU 中央处理器 central processing unit 2. PC 程序计数器 program counter","text":"计算机的基本部件1. CPU 中央处理器 central processing unit 2. PC 程序计数器 program counter 3. MAR 存储器地址寄存器 memory address register 4. ALU 算数逻辑部件 5. IR 指令寄存器 6. MDR 存储器数据寄存器 memory data register 7. GPRs 通用寄存器组","categories":[{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"http://blog.zhouyajun.cn/categories/深入理解计算机系统/"}],"tags":[{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"http://blog.zhouyajun.cn/tags/深入理解计算机系统/"}]},{"title":"jenkins内存溢出修复","slug":"jenkins内存溢出修复","date":"2018-06-25T06:15:42.000Z","updated":"2019-06-04T03:31:43.628Z","comments":true,"path":"2018/06/25/jenkins内存溢出修复/","link":"","permalink":"http://blog.zhouyajun.cn/2018/06/25/jenkins内存溢出修复/","excerpt":"","text":"Jenkins 内存溢出修复找到jenkins的配置文件 vi /etc/sysconfig/jenkins 修改JAVA_OPTIONS的值找到JENKINS_JAVA_OPTIONS=&quot;-Djava.awt.headless&quot;将值修改成 “-Djava.awt.headless=true -Xms256m -Xmx512m -XX:MaxNewSize=256m -XX:MaxPermSize=256m” 具体参数根据自己的机器实际情况调整。","categories":[{"name":"jenkins","slug":"jenkins","permalink":"http://blog.zhouyajun.cn/categories/jenkins/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://blog.zhouyajun.cn/tags/jenkins/"}]},{"title":"hexo+github page博客配置个人域名","slug":"hexo-github-page博客配置个人域名","date":"2018-05-10T02:30:00.000Z","updated":"2019-06-04T03:31:43.632Z","comments":true,"path":"2018/05/10/hexo-github-page博客配置个人域名/","link":"","permalink":"http://blog.zhouyajun.cn/2018/05/10/hexo-github-page博客配置个人域名/","excerpt":"","text":"首先肯定是得有个 个人域名 啦~,然后创建一条CNAME记录，指向到youname.github.io 在hexo项目的source目录下新建CNAME文件,里面填写你刚刚绑定的个人域名 然后执行,推送到github上，github会自动处理，过个几分钟，访问个人域名就可以了 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.zhouyajun.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.zhouyajun.cn/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://blog.zhouyajun.cn/tags/博客/"}]},{"title":"php命名空间","slug":"php命名空间","date":"2016-06-29T16:00:00.000Z","updated":"2019-06-04T03:31:43.633Z","comments":true,"path":"2016/06/30/php命名空间/","link":"","permalink":"http://blog.zhouyajun.cn/2016/06/30/php命名空间/","excerpt":"","text":"命名空间(php 5.3+)@(php) 如何定义命名空间行命名空间语法： namespace zyj大括号命名空间语法： namespace zyj{} 注意：不能再一个文件中同时使用这两种命名方法，你必须选择其中的一种，并且在整个文件中坚持使用 use关键字1. 引用命名空间中的类 use /zyj/Code 代表引用zyj空间下的code类 2. 给一个类起别名 use /zyj/Code as ZyjCode 3. 匿名函数中引用父方法中的变量 12345678&lt;?php function test()&#123; $count = 1; return function($test) use ($count)&#123; return $test+$count; &#125; &#125;?&gt;","categories":[{"name":"php","slug":"php","permalink":"http://blog.zhouyajun.cn/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://blog.zhouyajun.cn/tags/php/"}]},{"title":"call_user_func,call_user_func_array,is_callback","slug":"php函数（call-user-func-is-callback）","date":"2016-06-28T16:00:00.000Z","updated":"2019-06-04T03:31:43.633Z","comments":true,"path":"2016/06/29/php函数（call-user-func-is-callback）/","link":"","permalink":"http://blog.zhouyajun.cn/2016/06/29/php函数（call-user-func-is-callback）/","excerpt":"","text":"新建一个类12345678910111213141516171819class Test&#123; public $name = 'name'; public function index() &#123; return 'normal function' .$this-&gt;name; &#125; public static function index2() &#123; return 'static function'; &#125; public static function index3() &#123; return function ()&#123;&#125;; &#125;&#125; is_callback($callback) 注：判断是否为回调函数 12345678//对象调用is_callback([new Test(),'index']); 返回 true//类调用is_callback(['Test','index2]); 返回 true//命名空间调用is_callback('Test::index'); 返回 ture//直接回调函数is_callback(Test::index3()); 返回 ture call_user_func($callback,$arg1,$arg2); 注：调用回调函数返回：回调函数返回的结果 123456789//对象调用call_user_func([new Test(),'index'])//类调用call_user_func(['Test','index']);//命名空间调用（不建议使用）call_user_func('Test::index');这种方法弱index是静态方法没问题，不是静态方法可能报错，本文的事例代码调用会报错//直接调用回调函数call_user_function(Test::index3()); call_user_func_array($callback,array($arg1,$arg2)); 注：调用回调函数,参数为数组,$arg1为回调函数的第一个参数，$arg2为第二个，以此类推返回：回调函数返回的结果 123456789//对象调用call_user_func([new Test(),'index'],array($arg1,$arg2))//类调用call_user_func(['Test','index'],array($arg1,$arg2));//命名空间调用（不建议使用）call_user_func('Test::index',array($arg1,$arg2));这种方法弱index是静态方法没问题，不是静态方法可能报错，本文的事例代码调用会报错//直接调用回调函数call_user_function(Test::index3(),array($arg1,$arg2));","categories":[{"name":"php","slug":"php","permalink":"http://blog.zhouyajun.cn/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://blog.zhouyajun.cn/tags/php/"},{"name":"php函数","slug":"php函数","permalink":"http://blog.zhouyajun.cn/tags/php函数/"}]},{"title":"php引用详解","slug":"php引用详解","date":"2016-06-27T16:00:00.000Z","updated":"2019-06-04T03:31:43.633Z","comments":true,"path":"2016/06/28/php引用详解/","link":"","permalink":"http://blog.zhouyajun.cn/2016/06/28/php引用详解/","excerpt":"","text":"引用是什么 PHP 中的引用意味着不同的变量名字访问同一个变量内容 引用可以被看作是 Unix 文件系统中的硬链接 引用是做什么1.引用赋值 注：这意味着变量a和变量b指向同一个内容，无论改变哪个变量的值，另一个变量的值都会改变注：$a 和 $b 在这里是完全相同的，这并不是 $a 指向了 $b 或者相反，而是 $a 和 $b 指向了同一个地方 12345&lt;?php$a = 1;$b = 3;$a = &amp;$b;?&gt; 注：如果对一个未定义的变量进行引用赋值、引用参数传递或引用返回，则会自动创建该变量 12345678910111213&lt;?phpfunction foo(&amp;$var) &#123; &#125;foo($a); // $a is \"created\" and assigned to null$b = array();foo($b['b']);var_dump(array_key_exists('b', $b)); // bool(true)$c = new StdClass;foo($c-&gt;d);var_dump(property_exists($c, 'd')); // bool(true)?&gt; 注：如果具有引用的数组被拷贝，其值不会解除引用。对于数组传值给函数也是如此 1234567891011&lt;?php$a = array(1,3,2);$b = 1;$b = &amp;$a;var_dump($b);var_dump($a);$a[] = 4;var_dump($b); // array(1,3,2,4)var_dump($a); // array(1,3,2,4)exit;?&gt; 注：如果在一个函数内部给一个声明为 global 的变量赋于一个引用，该引用只在函数内部可见。可以通过使用 $GLOBALS 数组避免这一点 1234567891011121314151617181920&lt;?php$var1 = \"Example variable\";$var2 = \"\";function global_references($use_globals)&#123; global $var1, $var2; if (!$use_globals) &#123; $var2 =&amp; $var1; // visible only inside the function &#125; else &#123; $GLOBALS[\"var2\"] =&amp; $var1; // visible also in global context &#125;&#125;global_references(false);echo \"var2 is set to '$var2'\\n\"; // var2 is set to ''global_references(true);echo \"var2 is set to '$var2'\\n\"; // var2 is set to 'Example variable'?&gt; ?&gt; 注：如果在 foreach 语句中给一个具有引用的变量赋值，被引用的对象也被改变 12345678&lt;?php$ref = 0;$row =&amp; $ref;foreach (array(1, 2, 3) as $row) &#123; // do something&#125;echo $ref; // 3 - last element of the iterated array?&gt; 2.引用传递 注： 可以将一个变量通过引用传递给函数，这样该函数就可以修改其参数的值 1234567891011&lt;?php $b = 2; $a = 1; function a(&amp;$b)&#123; $b += 100; &#125; a($a); var_dump($a); // 101 var_dump($b); // 2?&gt; 3.引用返回 注： 引用返回用在当想用函数找到引用应该被绑定在哪一个变量上面时 123456789101112131415&lt;?php class foo &#123; public $value = 42; public function &amp;getValue() &#123; return $this-&gt;value; &#125;&#125;$obj = new foo;$myValue = &amp;$obj-&gt;getValue(); // $myValue is a reference to $obj-&gt;value, which is 42.$obj-&gt;value = 2;echo $myValue; // prints the new value of $obj-&gt;value, i.e. 2.?&gt;","categories":[{"name":"php","slug":"php","permalink":"http://blog.zhouyajun.cn/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://blog.zhouyajun.cn/tags/php/"}]},{"title":"require和include","slug":"require和include","date":"2016-06-27T16:00:00.000Z","updated":"2019-06-04T03:31:43.634Z","comments":true,"path":"2016/06/28/require和include/","link":"","permalink":"http://blog.zhouyajun.cn/2016/06/28/require和include/","excerpt":"","text":"require和include1. 作用 用户引入文件，可以减少代码重复 2.注意 require 和 include都是语法结构不是函数，因此一下两种访问方法都可以 12require 'index.php';require('index.php'); 3.区别 区别主要体现在对错误的处理上require和require_once在发生错误是会触发致命错误，将会停止整个应用程序include和include_once在发生错误时会发出警告，程序会继续运行 4.建议用法 require和require_once可以用于加载库文件include和include_once可以用户加载模板文件 5.once的区别 带_once（require_once,include_once）,载入文件的时候会判断是否已经加载，不会加载第二次，但是性能上有所消耗，还是建议在不会重复加载的基础上使用 不带_once的（require和include）","categories":[{"name":"php","slug":"php","permalink":"http://blog.zhouyajun.cn/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://blog.zhouyajun.cn/tags/php/"}]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2016-06-24T16:00:00.000Z","updated":"2019-06-04T03:31:43.633Z","comments":true,"path":"2016/06/25/hexo常用命令/","link":"","permalink":"http://blog.zhouyajun.cn/2016/06/25/hexo常用命令/","excerpt":"","text":"清空缓存hexo c = hexo clean 生成algolia搜索（已经生成静态网页）hexo algolia 生成静态网页hexo g = hexo generate 本地测试环境hexo s -p 80 = hexo server -p 80 新建文章hexo n &quot;我的博客&quot; = hexo new &quot;我的博客&quot; #新建文章 部署hexo d = hexo deploy","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.zhouyajun.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.zhouyajun.cn/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://blog.zhouyajun.cn/tags/博客/"}]}]}